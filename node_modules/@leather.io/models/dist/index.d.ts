import BigNumber, { BigNumber as BigNumber$1 } from 'bignumber.js';
import { z } from 'zod';
import { MempoolTransaction, Transaction } from '@stacks/stacks-blockchain-api-types';

type BitcoinAddress = string & {
    readonly __brand: unique symbol;
};
type BitcoinUnit = 'bitcoin' | 'satoshi';
type BitcoinUnitSymbol = 'BTC' | 'sat';
interface BitcoinUnitInfo {
    name: BitcoinUnit;
    symbol: BitcoinUnitSymbol;
    decimal: string;
}

type ValueOf<T> = T[keyof T];
interface AllowAdditionalProperties {
    [x: string | number | symbol]: unknown;
}
type Primitive = null | undefined | string | number | boolean | symbol | bigint;
type LiteralUnion<LiteralType, BaseType extends Primitive> = LiteralType | (BaseType & Record<never, never>);
type Entries<T> = {
    [K in keyof T]: [K, T[K]];
}[keyof T][];
type ReplaceTypes<T, Replacements extends {
    [K in keyof T]?: any;
}> = Omit<T, keyof Replacements> & {
    [K in keyof Replacements]: Replacements[K];
};
type Prettify<T> = {
    [K in keyof T]: T[K];
} & {};

type CryptoCurrency = LiteralUnion<'BTC' | 'STX', string>;
type FiatCurrency = LiteralUnion<'USD' | 'EUR' | 'GBP' | 'AUD' | 'CAD' | 'CNY' | 'JPY' | 'KRW', string>;
type Currency = CryptoCurrency | FiatCurrency;

type NumType = BigNumber | bigint | number;
interface Money {
    readonly amount: BigNumber;
    readonly symbol: Currency;
    readonly decimals: number;
}

interface BaseCryptoAssetBalance {
    /**
     * Balance as confirmed on chain
     */
    readonly totalBalance: Money;
    /**
     * Balance of pending receipt into account given pending transactions
     */
    readonly inboundBalance: Money;
    /**
     * Balance of pending delivery from account given pending transactions
     */
    readonly outboundBalance: Money;
    /**
     * totalBalance plus inboundBalance minus outboundBalance
     */
    readonly pendingBalance: Money;
    /**
     * totalBalance after filtering out outboundBalance, protectedBalance, and uneconomicalBalance
     */
    readonly availableBalance: Money;
}
interface BtcCryptoAssetBalance extends BaseCryptoAssetBalance {
    /**
     * Balance of UTXOs with collectibles
     */
    readonly protectedBalance: Money;
    /**
     * Balance across UTXOs with need for larger fee than principal by UTXO given standard rate
     */
    readonly uneconomicalBalance: Money;
    /**
     * Balance of the union set of protected and uneconomical UTXOs
     */
    readonly unspendableBalance: Money;
}
interface StxCryptoAssetBalance extends BaseCryptoAssetBalance {
    /**
     * availableBalance minus lockedBalance
     */
    readonly availableUnlockedBalance: Money;
    /**
     * total amount locked by contracts
     */
    readonly lockedBalance: Money;
    /**
     * totalBalance minus lockedBalance
     */
    readonly unlockedBalance: Money;
}
type CryptoAssetBalance = BaseCryptoAssetBalance | BtcCryptoAssetBalance | StxCryptoAssetBalance;

/**
 * Inscriptions contain arbitrary data. When retrieving an inscription, it should be
 * classified into one of the types below, indicating that the app can handle it
 * appropriately and securely. Inscriptions of types not ready to be handled by the
 * app should be classified as "other".
 */
declare const inscriptionMimeTypes: readonly ["audio", "gltf", "html", "image", "svg", "text", "video", "other"];
type InscriptionMimeType = (typeof inscriptionMimeTypes)[number];
declare function whenInscriptionMimeType<T>(mimeType: string, branches: {
    [k in InscriptionMimeType]?: () => T;
}): T;
interface Inscription extends InscriptionCryptoAssetInfo {
    preview: string;
    src: string;
    title: string;
    output: string;
    txid: string;
    offset: string;
    address: string;
    genesisBlockHash: string;
    genesisTimestamp: number;
    genesisBlockHeight: number;
    value: string;
}
interface RawInscription {
    id: string;
    number: number;
    output: string;
    contentType: string;
    txid: string;
    offset: string;
    address: string;
    genesisBlockHash: string;
    genesisTimestamp: number;
    genesisBlockHeight: number;
    value: string;
}
declare function createInscription(inscription: RawInscription): Inscription;

declare const CryptoAssetChains: {
    readonly bitcoin: "bitcoin";
    readonly stacks: "stacks";
};
declare const CryptoAssetCategories: {
    readonly fungible: "fungible";
    readonly nft: "nft";
};
declare const CryptoAssetProtocols: {
    readonly nativeBtc: "nativeBtc";
    readonly nativeStx: "nativeStx";
    readonly sip10: "sip10";
    readonly brc20: "brc20";
    readonly src20: "src20";
    readonly stx20: "stx20";
    readonly rune: "rune";
    readonly stamp: "stamp";
    readonly sip9: "sip9";
    readonly inscription: "inscription";
};
type CryptoAssetChain = keyof typeof CryptoAssetChains;
type CryptoAssetCategory = keyof typeof CryptoAssetCategories;
type CryptoAssetProtocol = keyof typeof CryptoAssetProtocols;
interface BaseCryptoAssetInfo {
    readonly chain: CryptoAssetChain;
    readonly category: CryptoAssetCategory;
    readonly protocol: CryptoAssetProtocol;
}
interface BaseFungibleCryptoAssetInfo extends BaseCryptoAssetInfo {
    readonly category: 'fungible';
    readonly symbol: string;
    readonly decimals: number;
    readonly hasMemo: boolean;
}
interface BtcCryptoAssetInfo extends BaseFungibleCryptoAssetInfo {
    readonly chain: 'bitcoin';
    readonly protocol: 'nativeBtc';
    readonly symbol: 'BTC';
}
interface StxCryptoAssetInfo extends BaseFungibleCryptoAssetInfo {
    readonly chain: 'stacks';
    readonly protocol: 'nativeStx';
    readonly symbol: 'STX';
}
interface Brc20CryptoAssetInfo extends BaseFungibleCryptoAssetInfo {
    readonly chain: 'bitcoin';
    readonly protocol: 'brc20';
    readonly symbol: string;
}
interface Src20CryptoAssetInfo extends BaseFungibleCryptoAssetInfo {
    readonly chain: 'bitcoin';
    readonly protocol: 'src20';
    readonly id: string;
    readonly symbol: string;
    readonly deploy_tx: string;
    readonly deploy_img: string;
}
interface RuneCryptoAssetInfo extends BaseFungibleCryptoAssetInfo {
    readonly chain: 'bitcoin';
    readonly protocol: 'rune';
    readonly spacedRuneName: string;
    readonly runeName: string;
    readonly symbol: string;
}
interface Sip10CryptoAssetInfo extends BaseFungibleCryptoAssetInfo {
    readonly chain: 'stacks';
    readonly protocol: 'sip10';
    readonly name: string;
    readonly canTransfer: boolean;
    readonly assetId: string;
    readonly contractId: string;
    readonly imageCanonicalUri: string;
    readonly symbol: string;
}
interface Stx20CryptoAssetInfo extends BaseFungibleCryptoAssetInfo {
    readonly chain: 'stacks';
    readonly protocol: 'stx20';
    readonly symbol: string;
}
type NativeCryptoAssetInfo = BtcCryptoAssetInfo | StxCryptoAssetInfo;
type FungibleCryptoAssetInfo = NativeCryptoAssetInfo | Sip10CryptoAssetInfo | Brc20CryptoAssetInfo | Src20CryptoAssetInfo | Stx20CryptoAssetInfo | RuneCryptoAssetInfo;
interface BaseNonFungibleCryptoAssetInfo extends BaseCryptoAssetInfo {
    readonly category: 'nft';
}
interface InscriptionCryptoAssetInfo extends BaseNonFungibleCryptoAssetInfo {
    readonly chain: 'bitcoin';
    readonly protocol: 'inscription';
    readonly id: string;
    readonly mimeType: InscriptionMimeType;
    readonly number: number;
    readonly preview: string;
    readonly src: string;
    readonly title: string;
    readonly output: string;
    readonly txid: string;
    readonly offset: string;
    readonly address: string;
    readonly genesisBlockHash: string;
    readonly genesisTimestamp: number;
    readonly genesisBlockHeight: number;
    readonly value: string;
}
interface StampCryptoAssetInfo extends BaseNonFungibleCryptoAssetInfo {
    readonly chain: 'bitcoin';
    readonly protocol: 'stamp';
    readonly stamp: number;
    readonly stampUrl: string;
}
interface Sip9CryptoAssetInfo extends BaseNonFungibleCryptoAssetInfo {
    readonly chain: 'stacks';
    readonly protocol: 'sip9';
    readonly assetId: string;
    readonly contractId: string;
    readonly name: string;
    readonly description: string;
    readonly cachedImage: string;
    readonly cachedImageThumbnail: string;
}
type NonFungibleCryptoAssetInfo = InscriptionCryptoAssetInfo | StampCryptoAssetInfo | Sip9CryptoAssetInfo;
type CryptoAssetInfo = FungibleCryptoAssetInfo | NonFungibleCryptoAssetInfo;

interface AverageBitcoinFeeRates {
    fastestFee: BigNumber;
    halfHourFee: BigNumber;
    hourFee: BigNumber;
}
declare const btcTxTimeMap: Record<keyof AverageBitcoinFeeRates, string>;
declare enum BtcFeeType {
    High = "High",
    Standard = "Standard",
    Low = "Low"
}

type Blockchain = LiteralUnion<'bitcoin' | 'stacks', string>;

interface StacksFeeEstimate {
    fee: Money;
    feeRate: number;
}

declare enum FeeTypes {
    Low = 0,
    Middle = 1,
    High = 2,
    Custom = 3,
    Unknown = 4
}
declare enum FeeCalculationTypes {
    Api = "api",
    Default = "default",
    DefaultSimulated = "default-simulated",
    FeesCapped = "fees-capped",
    TokenTransferSpecific = "token-transfer-specific"
}
interface Fees {
    blockchain: Blockchain;
    estimates: StacksFeeEstimate[];
    calculation: FeeCalculationTypes;
}

interface MarketPair {
    readonly base: CryptoCurrency;
    readonly quote: FiatCurrency;
}
declare function createMarketPair(base: CryptoCurrency, quote: FiatCurrency): MarketPair;
declare function formatMarketPair({ base, quote }: MarketPair): string;
interface MarketData {
    readonly pair: MarketPair;
    readonly price: Money;
}
declare function createMarketData(pair: MarketPair, price: Money): MarketData;

declare const bitcoinNetworkModesSchema: z.ZodEnum<["mainnet", "testnet", "testnet", "regtest", "signet"]>;
declare const bitcoinNetworkSchema: z.ZodEnum<["mainnet", "testnet3", "testnet4", "regtest", "signet"]>;
declare const networkConfigurationSchema: z.ZodObject<{
    name: z.ZodString;
    id: z.ZodString;
    chain: z.ZodObject<{
        bitcoin: z.ZodObject<{
            blockchain: z.ZodLiteral<"bitcoin">;
            bitcoinUrl: z.ZodString;
            bitcoinNetwork: z.ZodEnum<["mainnet", "testnet3", "testnet4", "regtest", "signet"]>;
            mode: z.ZodEnum<["mainnet", "testnet", "testnet", "regtest", "signet"]>;
        }, "strip", z.ZodTypeAny, {
            blockchain: "bitcoin";
            bitcoinUrl: string;
            bitcoinNetwork: "mainnet" | "regtest" | "signet" | "testnet3" | "testnet4";
            mode: "mainnet" | "testnet" | "regtest" | "signet";
        }, {
            blockchain: "bitcoin";
            bitcoinUrl: string;
            bitcoinNetwork: "mainnet" | "regtest" | "signet" | "testnet3" | "testnet4";
            mode: "mainnet" | "testnet" | "regtest" | "signet";
        }>;
        stacks: z.ZodObject<{
            blockchain: z.ZodLiteral<"stacks">;
            url: z.ZodString;
            chainId: z.ZodNumber;
            subnetChainId: z.ZodOptional<z.ZodNumber>;
        }, "strip", z.ZodTypeAny, {
            blockchain: "stacks";
            url: string;
            chainId: number;
            subnetChainId?: number | undefined;
        }, {
            blockchain: "stacks";
            url: string;
            chainId: number;
            subnetChainId?: number | undefined;
        }>;
    }, "strip", z.ZodTypeAny, {
        bitcoin: {
            blockchain: "bitcoin";
            bitcoinUrl: string;
            bitcoinNetwork: "mainnet" | "regtest" | "signet" | "testnet3" | "testnet4";
            mode: "mainnet" | "testnet" | "regtest" | "signet";
        };
        stacks: {
            blockchain: "stacks";
            url: string;
            chainId: number;
            subnetChainId?: number | undefined;
        };
    }, {
        bitcoin: {
            blockchain: "bitcoin";
            bitcoinUrl: string;
            bitcoinNetwork: "mainnet" | "regtest" | "signet" | "testnet3" | "testnet4";
            mode: "mainnet" | "testnet" | "regtest" | "signet";
        };
        stacks: {
            blockchain: "stacks";
            url: string;
            chainId: number;
            subnetChainId?: number | undefined;
        };
    }>;
}, "strip", z.ZodTypeAny, {
    name: string;
    id: string;
    chain: {
        bitcoin: {
            blockchain: "bitcoin";
            bitcoinUrl: string;
            bitcoinNetwork: "mainnet" | "regtest" | "signet" | "testnet3" | "testnet4";
            mode: "mainnet" | "testnet" | "regtest" | "signet";
        };
        stacks: {
            blockchain: "stacks";
            url: string;
            chainId: number;
            subnetChainId?: number | undefined;
        };
    };
}, {
    name: string;
    id: string;
    chain: {
        bitcoin: {
            blockchain: "bitcoin";
            bitcoinUrl: string;
            bitcoinNetwork: "mainnet" | "regtest" | "signet" | "testnet3" | "testnet4";
            mode: "mainnet" | "testnet" | "regtest" | "signet";
        };
        stacks: {
            blockchain: "stacks";
            url: string;
            chainId: number;
            subnetChainId?: number | undefined;
        };
    };
}>;

declare const HIRO_API_BASE_URL_MAINNET = "https://api.hiro.so";
declare const HIRO_API_BASE_URL_TESTNET = "https://api.testnet.hiro.so";
declare const HIRO_INSCRIPTIONS_API_URL = "https://api.hiro.so/ordinals/v1/inscriptions";
declare const HIRO_API_BASE_URL_NAKAMOTO_TESTNET = "https://api.nakamoto.testnet.hiro.so";
declare const HIRO_API_BASE_URL_MAINNET_EXTENDED = "https://api.hiro.so/extended/v1";
declare const HIRO_API_BASE_URL_TESTNET_EXTENDED = "https://api.testnet.hiro.so/extended";
declare const BITCOIN_API_BASE_URL_MAINNET = "https://leather.mempool.space/api";
declare const BITCOIN_API_BASE_URL_TESTNET3 = "https://leather.mempool.space/testnet/api";
declare const BITCOIN_API_BASE_URL_TESTNET4 = "https://leather.mempool.space/testnet4/api";
declare const BITCOIN_API_BASE_URL_SIGNET = "https://mempool.space/signet/api";
declare const BESTINSLOT_API_BASE_URL_MAINNET = "https://leatherapi.bestinslot.xyz/v3";
declare const BESTINSLOT_API_BASE_URL_TESTNET = "https://leatherapi_testnet.bestinslot.xyz/v3";
declare const STX20_API_BASE_URL_MAINNET = "https://api.stx20.com/api/v1";
declare const BNS_V2_API_BASE_URL = "https://api.bnsv2.com";
declare enum ChainId {
    Testnet = 2147483648,
    Mainnet = 1
}
declare enum WalletDefaultNetworkConfigurationIds {
    mainnet = "mainnet",
    testnet = "testnet",
    testnet4 = "testnet4",
    signet = "signet",
    sbtcTestnet = "sbtcTestnet",
    sbtcDevenv = "sbtcDevenv",
    devnet = "devnet"
}
type DefaultNetworkConfigurations = keyof typeof WalletDefaultNetworkConfigurationIds;
declare const supportedBlockchains: readonly ["stacks", "bitcoin"];
type SupportedBlockchains = (typeof supportedBlockchains)[number];
declare const networkModes: readonly ["mainnet", "testnet"];
declare const testnetModes: readonly ["testnet", "regtest", "signet"];
declare const bitcoinNetworks: readonly ["mainnet", "testnet3", "testnet4", "regtest", "signet"];
type BitcoinNetwork = (typeof bitcoinNetworks)[number];
type NetworkModes = (typeof networkModes)[number];
type BitcoinTestnetModes = (typeof testnetModes)[number];
declare function bitcoinNetworkToNetworkMode(network: BitcoinNetwork): BitcoinNetworkModes;
type BitcoinNetworkModes = NetworkModes | BitcoinTestnetModes;
interface BaseChainConfig {
    blockchain: Blockchain;
}
interface BitcoinChainConfig extends BaseChainConfig {
    blockchain: 'bitcoin';
    bitcoinUrl: string;
    bitcoinNetwork: BitcoinNetwork;
    mode: BitcoinNetworkModes;
}
interface StacksChainConfig extends BaseChainConfig {
    blockchain: 'stacks';
    url: string;
    /** The chainId of the network (or parent network if this is a subnet) */
    chainId: ChainId;
    /** An additional chainId for subnets. Indicated a subnet if defined and is mainly used for signing. */
    subnetChainId?: ChainId;
}
type NetworkConfiguration = z.infer<typeof networkConfigurationSchema>;
declare const defaultCurrentNetwork: NetworkConfiguration;
declare const defaultNetworksKeyedById: Record<WalletDefaultNetworkConfigurationIds, NetworkConfiguration>;

type AccountDisplayPreference = 'native-segwit' | 'taproot' | 'bns' | 'stacks';
interface AccountDisplayPreferenceInfo {
    type: AccountDisplayPreference;
    blockchain: Blockchain;
    name: string;
}
type AnalyticsPreference = 'consent-given' | 'rejects-tracking';
declare const emailAddressSchema: z.ZodString;
type EmailAddress = z.infer<typeof emailAddressSchema>;

interface BitcoinTransactionIssuance {
    asset_id: string;
    is_reissuance: boolean;
    asset_blinding_nonce: number;
    asset_entropy: number;
    contract_hash: string;
    assetamount?: number;
    assetamountcommitment?: number;
    tokenamount?: number;
    tokenamountcommitment?: number;
}
interface BitcoinTransactionPegOut {
    genesis_hash: string;
    scriptpubkey: string;
    scriptpubkey_asm: string;
    scriptpubkey_address: string;
}
interface BitcoinTransactionStatus {
    confirmed: boolean;
    block_height?: number | null;
    block_hash?: string | null;
    block_time?: number | null;
}
interface BitcoinTransactionVectorOutput {
    scriptpubkey: string;
    scriptpubkey_asm: string;
    scriptpubkey_type: string;
    scriptpubkey_address: string;
    value: number;
    valuecommitment?: number;
    asset?: string;
    assetcommitment?: number;
    pegout?: BitcoinTransactionPegOut | null;
}
interface BitcoinTransactionVectorInput {
    inner_redeemscript_asm?: string;
    inner_witnessscript_asm?: string;
    is_coinbase: boolean;
    is_pegin?: boolean;
    issuance?: BitcoinTransactionIssuance | null;
    prevout: BitcoinTransactionVectorOutput;
    scriptsig: string;
    scriptsig_asm: string;
    sequence: number;
    txid: string;
    vout: number;
    witness: string[];
}
interface BitcoinTx {
    fee: number;
    locktime: number;
    size: number;
    status: BitcoinTransactionStatus;
    tx_type?: string;
    txid: string;
    version: number;
    vin: BitcoinTransactionVectorInput[];
    vout: BitcoinTransactionVectorOutput[];
    weight: number;
}

type StacksTx = MempoolTransaction | Transaction;
type StacksTxStatus = 'failed' | 'pending' | 'success';
interface StxTransfer {
    amount: string;
    sender?: string;
    recipient?: string;
}
interface FtTransfer {
    asset_identifier: string;
    amount: string;
    sender?: string;
    recipient?: string;
}

type TransactionErrorKey = 'InvalidAddress' | 'InsufficientFunds' | 'InvalidAmount' | 'InvalidNetworkAddress' | 'InvalidPrecision' | 'InvalidTransaction' | 'NonCompliantAddress';

interface UtxoId {
    txid: string;
    vout: number;
}
interface Utxo extends UtxoId {
    height?: number;
    address: string;
    path: string;
    value: string;
}

declare const ActivityLevels: {
    readonly account: "account";
    readonly app: "app";
};
type ActivityLevel = keyof typeof ActivityLevels;

declare const OnChainActivityStatuses: {
    readonly pending: "pending";
    readonly success: "success";
    readonly failed: "failed";
};
type OnChainActivityStatus = keyof typeof OnChainActivityStatuses;

declare const OnChainActivityTypes: {
    readonly deploySmartContract: "deploySmartContract";
    readonly executeSmartContract: "executeSmartContract";
    readonly lockAsset: "lockAsset";
    readonly sendAsset: "sendAsset";
    readonly receiveAsset: "receiveAsset";
    readonly swapAssets: "swapAssets";
};
type OnChainActivityType = keyof typeof OnChainActivityTypes;
declare const WalletActivityTypes: {
    readonly connectApp: "connectApp";
    readonly signMessage: "signMessage";
};
type WalletActivityType = keyof typeof WalletActivityTypes;
declare const GeneralActivityTypes: {
    readonly walletAdded: "walletAdded";
    readonly receiveAnnouncement: "receiveAnnouncement";
    readonly featureWaitlistNotification: "featureWaitlistNotification";
};
type GeneralActivityType = keyof typeof GeneralActivityTypes;
type ActivityType = OnChainActivityType | WalletActivityType | GeneralActivityType;

declare const walletIdSchema: z.ZodObject<{
    fingerprint: z.ZodString;
}, "strip", z.ZodTypeAny, {
    fingerprint: string;
}, {
    fingerprint: string;
}>;
declare const accountIdSchema: z.ZodObject<z.objectUtil.extendShape<{
    fingerprint: z.ZodString;
}, {
    accountIndex: z.ZodNumber;
}>, "strip", z.ZodTypeAny, {
    fingerprint: string;
    accountIndex: number;
}, {
    fingerprint: string;
    accountIndex: number;
}>;
declare const bitcoinAddressInfoSchema: z.ZodObject<{
    taprootDescriptor: z.ZodString;
    nativeSegwitDescriptor: z.ZodString;
}, "strip", z.ZodTypeAny, {
    taprootDescriptor: string;
    nativeSegwitDescriptor: string;
}, {
    taprootDescriptor: string;
    nativeSegwitDescriptor: string;
}>;
declare const stacksAddressInfoSchema: z.ZodObject<{
    stxAddress: z.ZodString;
}, "strip", z.ZodTypeAny, {
    stxAddress: string;
}, {
    stxAddress: string;
}>;
declare const accountAddressesSchema: z.ZodObject<{
    id: z.ZodObject<z.objectUtil.extendShape<{
        fingerprint: z.ZodString;
    }, {
        accountIndex: z.ZodNumber;
    }>, "strip", z.ZodTypeAny, {
        fingerprint: string;
        accountIndex: number;
    }, {
        fingerprint: string;
        accountIndex: number;
    }>;
    bitcoin: z.ZodOptional<z.ZodObject<{
        taprootDescriptor: z.ZodString;
        nativeSegwitDescriptor: z.ZodString;
    }, "strip", z.ZodTypeAny, {
        taprootDescriptor: string;
        nativeSegwitDescriptor: string;
    }, {
        taprootDescriptor: string;
        nativeSegwitDescriptor: string;
    }>>;
    stacks: z.ZodOptional<z.ZodObject<{
        stxAddress: z.ZodString;
    }, "strip", z.ZodTypeAny, {
        stxAddress: string;
    }, {
        stxAddress: string;
    }>>;
}, "strip", z.ZodTypeAny, {
    id: {
        fingerprint: string;
        accountIndex: number;
    };
    bitcoin?: {
        taprootDescriptor: string;
        nativeSegwitDescriptor: string;
    } | undefined;
    stacks?: {
        stxAddress: string;
    } | undefined;
}, {
    id: {
        fingerprint: string;
        accountIndex: number;
    };
    bitcoin?: {
        taprootDescriptor: string;
        nativeSegwitDescriptor: string;
    } | undefined;
    stacks?: {
        stxAddress: string;
    } | undefined;
}>;
type WalletId = z.infer<typeof walletIdSchema>;
type AccountId = z.infer<typeof accountIdSchema>;
type BitcoinAddressInfo = z.infer<typeof bitcoinAddressInfoSchema>;
type StacksAddressInfo = z.infer<typeof stacksAddressInfoSchema>;
type AccountAddresses = z.infer<typeof accountAddressesSchema>;

interface BaseActivity {
    readonly level: ActivityLevel;
    readonly type: ActivityType;
    readonly timestamp: number;
}
interface AccountLevelActivity extends BaseActivity {
    readonly level: 'account';
    readonly account: AccountId;
}
interface AppLevelActivity extends BaseActivity {
    readonly level: 'app';
}
interface BaseOnChainActivity extends AccountLevelActivity {
    readonly type: OnChainActivityType;
    readonly txid: string;
    readonly status: OnChainActivityStatus;
}
interface DeploySmartContractActivity extends BaseOnChainActivity {
    readonly type: 'deploySmartContract';
    readonly contractId: string;
}
interface ExecuteSmartContractActivity extends BaseOnChainActivity {
    readonly type: 'executeSmartContract';
    readonly contractId: string;
    readonly functionName: string;
}
interface LockAssetActivity extends BaseOnChainActivity {
    readonly type: 'lockAsset';
    readonly asset: CryptoAssetInfo;
    readonly amount: BigNumber$1;
    readonly value?: {
        crypto: Money;
        fiat: Money;
    };
}
interface SendAssetActivity extends BaseOnChainActivity {
    readonly type: 'sendAsset';
    readonly asset: CryptoAssetInfo;
    readonly receivers: string[];
    readonly amount: BigNumber$1;
    readonly value?: {
        crypto: Money;
        fiat: Money;
    };
}
interface ReceiveAssetActivity extends BaseOnChainActivity {
    readonly type: 'receiveAsset';
    readonly asset: CryptoAssetInfo;
    readonly senders: string[];
    readonly amount: BigNumber$1;
    readonly value?: {
        crypto: Money;
        fiat: Money;
    };
}
interface SwapAssetsActivity extends BaseOnChainActivity {
    readonly type: 'swapAssets';
    readonly fromAsset: CryptoAssetInfo;
    readonly fromAmount: BigNumber$1;
    readonly fromValue?: {
        crypto: Money;
        fiat: Money;
    };
    readonly toAsset: CryptoAssetInfo;
    readonly toAmount: BigNumber$1;
    readonly toValue?: {
        crypto: Money;
        fiat: Money;
    };
}
interface BaseWalletActivity extends AccountLevelActivity {
    readonly type: WalletActivityType;
}
interface ConnectAppActivity extends BaseWalletActivity {
    readonly type: 'connectApp';
    readonly appName: string;
    readonly appUrl: string;
}
interface SignMessageActivity extends BaseWalletActivity {
    readonly type: 'signMessage';
    readonly appName: string;
    readonly appUrl: string;
}
interface GeneralActivity extends AppLevelActivity {
    readonly type: GeneralActivityType;
    readonly title: string;
    readonly message: string;
}
type OnChainActivity = DeploySmartContractActivity | ExecuteSmartContractActivity | LockAssetActivity | SendAssetActivity | ReceiveAssetActivity | SwapAssetsActivity;
type WalletActivity = ConnectAppActivity | SignMessageActivity;
type Activity = OnChainActivity | WalletActivity | GeneralActivity;

export { type AccountAddresses, type AccountDisplayPreference, type AccountDisplayPreferenceInfo, type AccountId, type AccountLevelActivity, type Activity, type ActivityLevel, ActivityLevels, type ActivityType, type AllowAdditionalProperties, type AnalyticsPreference, type AppLevelActivity, type AverageBitcoinFeeRates, BESTINSLOT_API_BASE_URL_MAINNET, BESTINSLOT_API_BASE_URL_TESTNET, BITCOIN_API_BASE_URL_MAINNET, BITCOIN_API_BASE_URL_SIGNET, BITCOIN_API_BASE_URL_TESTNET3, BITCOIN_API_BASE_URL_TESTNET4, BNS_V2_API_BASE_URL, type BaseActivity, type BaseCryptoAssetBalance, type BaseCryptoAssetInfo, type BaseOnChainActivity, type BaseWalletActivity, type BitcoinAddress, type BitcoinAddressInfo, type BitcoinChainConfig, type BitcoinNetwork, type BitcoinNetworkModes, type BitcoinTransactionVectorInput, type BitcoinTransactionVectorOutput, type BitcoinTx, type BitcoinUnit, type BitcoinUnitInfo, type BitcoinUnitSymbol, type Blockchain, type Brc20CryptoAssetInfo, type BtcCryptoAssetBalance, type BtcCryptoAssetInfo, BtcFeeType, ChainId, type ConnectAppActivity, type CryptoAssetBalance, CryptoAssetCategories, type CryptoAssetCategory, type CryptoAssetChain, CryptoAssetChains, type CryptoAssetInfo, type CryptoAssetProtocol, CryptoAssetProtocols, type CryptoCurrency, type Currency, type DefaultNetworkConfigurations, type DeploySmartContractActivity, type EmailAddress, type Entries, type ExecuteSmartContractActivity, FeeCalculationTypes, FeeTypes, type Fees, type FiatCurrency, type FtTransfer, type FungibleCryptoAssetInfo, type GeneralActivity, type GeneralActivityType, GeneralActivityTypes, HIRO_API_BASE_URL_MAINNET, HIRO_API_BASE_URL_MAINNET_EXTENDED, HIRO_API_BASE_URL_NAKAMOTO_TESTNET, HIRO_API_BASE_URL_TESTNET, HIRO_API_BASE_URL_TESTNET_EXTENDED, HIRO_INSCRIPTIONS_API_URL, type Inscription, type InscriptionCryptoAssetInfo, type InscriptionMimeType, type LiteralUnion, type LockAssetActivity, type MarketData, type Money, type NativeCryptoAssetInfo, type NetworkConfiguration, type NetworkModes, type NonFungibleCryptoAssetInfo, type NumType, type OnChainActivity, type OnChainActivityStatus, OnChainActivityStatuses, type OnChainActivityType, OnChainActivityTypes, type Prettify, type ReceiveAssetActivity, type ReplaceTypes, type RuneCryptoAssetInfo, STX20_API_BASE_URL_MAINNET, type SendAssetActivity, type SignMessageActivity, type Sip10CryptoAssetInfo, type Sip9CryptoAssetInfo, type Src20CryptoAssetInfo, type StacksAddressInfo, type StacksChainConfig, type StacksFeeEstimate, type StacksTx, type StacksTxStatus, type StampCryptoAssetInfo, type Stx20CryptoAssetInfo, type StxCryptoAssetBalance, type StxCryptoAssetInfo, type StxTransfer, type SupportedBlockchains, type SwapAssetsActivity, type TransactionErrorKey, type Utxo, type UtxoId, type ValueOf, type WalletActivity, type WalletActivityType, WalletActivityTypes, WalletDefaultNetworkConfigurationIds, type WalletId, accountAddressesSchema, accountIdSchema, bitcoinAddressInfoSchema, bitcoinNetworkModesSchema, bitcoinNetworkSchema, bitcoinNetworkToNetworkMode, bitcoinNetworks, btcTxTimeMap, createInscription, createMarketData, createMarketPair, defaultCurrentNetwork, defaultNetworksKeyedById, emailAddressSchema, formatMarketPair, inscriptionMimeTypes, networkConfigurationSchema, networkModes, stacksAddressInfoSchema, supportedBlockchains, testnetModes, walletIdSchema, whenInscriptionMimeType };
