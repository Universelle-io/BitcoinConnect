// src/methods/bitcoin/send-transfer.ts
import { z as z2 } from "zod";

// src/rpc/schemas.ts
import { z } from "zod";
var rpcParameterByPositionSchema = z.string().array();
var rpcParameterByNameSchema = z.record(z.string(), z.unknown());
var rpcParameterSchema = z.union([
  rpcParameterByPositionSchema,
  rpcParameterByNameSchema,
  z.undefined()
]);
var rpcBasePropsSchema = z.object({
  jsonrpc: z.literal("2.0"),
  id: z.string()
});
function createRpcRequestSchema(method, paramsSchema) {
  if (!paramsSchema) return rpcBasePropsSchema.extend({ method: z.literal(method) });
  return rpcBasePropsSchema.extend({
    method: z.literal(method),
    params: paramsSchema
  });
}
var RpcErrorCode = /* @__PURE__ */ ((RpcErrorCode2) => {
  RpcErrorCode2[RpcErrorCode2["PARSE_ERROR"] = -32700] = "PARSE_ERROR";
  RpcErrorCode2[RpcErrorCode2["INVALID_REQUEST"] = -32600] = "INVALID_REQUEST";
  RpcErrorCode2[RpcErrorCode2["METHOD_NOT_FOUND"] = -32601] = "METHOD_NOT_FOUND";
  RpcErrorCode2[RpcErrorCode2["INVALID_PARAMS"] = -32602] = "INVALID_PARAMS";
  RpcErrorCode2[RpcErrorCode2["INTERNAL_ERROR"] = -32603] = "INTERNAL_ERROR";
  RpcErrorCode2[RpcErrorCode2["SERVER_ERROR"] = -32e3] = "SERVER_ERROR";
  RpcErrorCode2[RpcErrorCode2["USER_REJECTION"] = 4001] = "USER_REJECTION";
  RpcErrorCode2[RpcErrorCode2["METHOD_NOT_SUPPORTED"] = 4002] = "METHOD_NOT_SUPPORTED";
  return RpcErrorCode2;
})(RpcErrorCode || {});
var rpcErrorCodeSchema = z.nativeEnum(RpcErrorCode);
function createRpcErrorBodySchema(errorDataSchema) {
  return z.object({
    code: z.union([z.number(), rpcErrorCodeSchema]),
    message: z.string(),
    data: errorDataSchema.optional()
  });
}
function createRpcErrorResponseSchema(errorSchema) {
  return rpcBasePropsSchema.extend({ error: errorSchema });
}
var defaultErrorSchema = createRpcErrorBodySchema(z.any());
function createRpcSuccessResponseSchema(resultSchema) {
  return rpcBasePropsSchema.extend({ result: resultSchema });
}
function createRpcResponseSchema(resultSchema, errorSchema) {
  return z.union([
    createRpcSuccessResponseSchema(resultSchema),
    createRpcErrorResponseSchema(errorSchema)
  ]);
}
function defineRpcEndpoint(props) {
  const error = props.error ?? defaultErrorSchema;
  if ("params" in props) {
    return {
      method: props.method,
      params: props.params,
      result: props.result,
      error,
      request: createRpcRequestSchema(props.method, props.params),
      response: createRpcResponseSchema(props.result, error)
    };
  }
  return {
    method: props.method,
    result: props.result,
    error,
    request: createRpcRequestSchema(props.method),
    response: createRpcResponseSchema(props.result, error)
  };
}

// src/methods/bitcoin/send-transfer.ts
var sendTransferLegacyParamSchema = z2.object({
  account: z2.number().optional(),
  address: z2.string(),
  amount: z2.coerce.string(),
  network: z2.string()
});
var transferRecipientParamSchema = z2.object({
  address: z2.string(),
  amount: z2.coerce.string()
});
var rpcSendTransferParamsSchema = z2.object({
  account: z2.number().optional(),
  recipients: z2.array(transferRecipientParamSchema),
  network: z2.string()
});
var sendTransfer = defineRpcEndpoint({
  method: "sendTransfer",
  params: z2.union([sendTransferLegacyParamSchema, rpcSendTransferParamsSchema]),
  result: z2.object({
    txid: z2.string()
  })
});

// src/methods/bitcoin/sign-message.ts
import { z as z3 } from "zod";
var Bip322MessageTypesSchema = z3.enum(["legacy", "bip322"]);
var supportedPaymentTypesSchema = z3.enum(["p2tr", "p2wpkh"]);
var signMessageRequestParamsSchema = z3.object({
  type: Bip322MessageTypesSchema.optional(),
  account: z3.number().optional(),
  message: z3.string(),
  paymentType: supportedPaymentTypesSchema
}).passthrough();
var signMessage = defineRpcEndpoint({
  method: "signMessage",
  params: signMessageRequestParamsSchema,
  result: z3.object({
    signature: z3.string(),
    address: z3.string()
  }).passthrough()
});

// src/methods/bitcoin/sign-psbt.ts
import { z as z4 } from "zod";

// src/rpc/helpers.ts
import { isNumberOrNumberList, isUndefined } from "@leather.io/utils";
function testIsNumberOrArrayOfNumbers(value) {
  if (isUndefined(value)) return true;
  return isNumberOrNumberList(value);
}
function encodeBase64Json(payload) {
  const jsonString = JSON.stringify(payload);
  return btoa(jsonString);
}
function decodeBase64Json(encodedPayload) {
  const jsonString = atob(encodedPayload);
  return JSON.parse(jsonString);
}
function createRequestEncoder(schema) {
  function encode(request) {
    return encodeBase64Json(schema.parse(request));
  }
  function decode(encodedRequest) {
    const parsedJson = decodeBase64Json(encodedRequest);
    return schema.parse(parsedJson);
  }
  return { encode, decode };
}

// src/methods/bitcoin/sign-psbt.ts
var signatureHash = {
  DEFAULT: 0,
  ALL: 1,
  NONE: 2,
  SINGLE: 3,
  ALL_ANYONECANPAY: 129,
  NONE_ANYONECANPAY: 130,
  SINGLE_ANYONECANPAY: 131
};
var signPsbtRequestParamsSchema = z4.object({
  account: z4.number().optional(),
  allowedSighash: z4.array(z4.any()).optional(),
  broadcast: z4.boolean().optional(),
  hex: z4.string(),
  network: z4.string().optional(),
  signAtIndex: z4.union([z4.number(), z4.array(z4.number())]).optional().refine(testIsNumberOrArrayOfNumbers)
});
var signPsbtResponseBodySchema = z4.object({
  hex: z4.string(),
  txid: z4.string().optional()
});
var signPsbt = defineRpcEndpoint({
  method: "signPsbt",
  params: signPsbtRequestParamsSchema,
  result: signPsbtResponseBodySchema
});

// src/methods/get-addresses.ts
import { z as z5 } from "zod";
var bitcoinPaymentTypesSchema = z5.enum(["p2pkh", "p2sh", "p2wpkh-p2sh", "p2wpkh", "p2tr"]);
var btcAddressBaseSchema = z5.object({
  symbol: z5.literal("BTC"),
  type: bitcoinPaymentTypesSchema,
  address: z5.string(),
  publicKey: z5.string(),
  derivationPath: z5.string()
});
var nativeSegwitAddressSchema = btcAddressBaseSchema.extend({
  type: z5.literal("p2wpkh")
}).passthrough();
var taprootAddressSchema = btcAddressBaseSchema.extend({
  type: z5.literal("p2tr"),
  tweakedPublicKey: z5.string()
}).passthrough();
var btcAddressSchema = z5.discriminatedUnion("type", [
  nativeSegwitAddressSchema,
  taprootAddressSchema
]);
var stxAddressSchema = z5.object({
  symbol: z5.literal("STX"),
  address: z5.string(),
  publicKey: z5.string()
}).passthrough();
var addressSchema = z5.union([btcAddressSchema, stxAddressSchema]);
var addressResponseBodySchema = z5.object({ addresses: z5.array(addressSchema) }).passthrough();
var getAddresses = defineRpcEndpoint({
  method: "getAddresses",
  params: z5.object({ network: z5.string().optional() }).optional(),
  result: addressResponseBodySchema
});

// src/methods/get-info.ts
import { z as z6 } from "zod";
var getInfoResponseBodySchema = z6.object({
  version: z6.string(),
  supportedMethods: z6.array(z6.string()).optional()
});
var getInfo = defineRpcEndpoint({
  method: "getInfo",
  result: getInfoResponseBodySchema
});

// src/methods/open.ts
import { z as z7 } from "zod";
var open = defineRpcEndpoint({
  method: "open",
  params: z7.object({
    base: z7.string(),
    quote: z7.string()
  }),
  result: z7.object({
    message: z7.string()
  })
});

// src/methods/open-swap.ts
import { z as z8 } from "zod";
var openSwapRequestParamsSchema = z8.object({
  base: z8.string(),
  quote: z8.string()
});
var openSwapResponseBodySchema = z8.object({
  message: z8.string()
});
var openSwap = defineRpcEndpoint({
  method: "openSwap",
  params: openSwapRequestParamsSchema,
  result: openSwapResponseBodySchema
});

// src/methods/stacks/stx-call-contract.ts
import { z as z10 } from "zod";

// src/methods/stacks/_stacks-helpers.ts
import { z as z9 } from "zod";
var stacksTransactionDetailsSchema = z9.object({
  txid: z9.string(),
  transaction: z9.string()
});
var baseStacksTransactionConfigSchema = z9.object({
  address: z9.string().optional(),
  network: z9.union([
    z9.literal("mainnet"),
    z9.literal("testnet"),
    z9.literal("regtest"),
    z9.literal("devnet"),
    z9.literal("mocknet"),
    z9.string()
  ]).optional(),
  fee: z9.coerce.number().optional(),
  nonce: z9.coerce.number().optional(),
  // add pc later when imported from stacks.js
  postConditions: z9.array(z9.string()).optional(),
  postConditionMode: z9.union([z9.literal("allow"), z9.literal("deny")]).optional(),
  sponsored: z9.boolean().optional()
});

// src/methods/stacks/stx-call-contract.ts
var stxCallContract = defineRpcEndpoint({
  method: "stx_callContract",
  params: z10.intersection(
    z10.object({
      contract: z10.string(),
      functionName: z10.string(),
      functionArgs: z10.array(z10.string()).optional()
    }),
    baseStacksTransactionConfigSchema
  ),
  result: stacksTransactionDetailsSchema
});

// src/methods/stacks/stx-deploy-contract.ts
import { z as z11 } from "zod";
var stxDeployContractResponseBodySchema = stacksTransactionDetailsSchema;
var stxDeployContract = defineRpcEndpoint({
  method: "stx_deployContract",
  params: z11.intersection(
    z11.object({
      name: z11.string(),
      clarityCode: z11.string(),
      clarityVersion: z11.coerce.number().optional()
    }),
    baseStacksTransactionConfigSchema
  ),
  result: stxDeployContractResponseBodySchema
});

// src/methods/stacks/stx-get-addresses.ts
import { z as z12 } from "zod";
var stxAddressItemSchema = z12.object({
  address: z12.string(),
  publicKey: z12.string(),
  derivationPath: z12.string()
});
var stxGetAddressesResponseBodySchema = z12.array(stxAddressItemSchema);
var stxGetAddresses = defineRpcEndpoint({
  method: "stx_getAddresses",
  params: z12.object({ network: z12.string().optional() }).optional(),
  result: stxGetAddressesResponseBodySchema
});

// src/methods/stacks/stx-get-networks.ts
import { z as z13 } from "zod";
var stxGetNetworks = defineRpcEndpoint({
  method: "stx_getNetworks",
  result: z13.object({
    active: z13.string(),
    networks: z13.array(
      z13.object({
        id: z13.string(),
        chainId: z13.string(),
        transactionVersion: z13.string()
      }).passthrough()
    )
  })
});

// src/methods/stacks/stx-sign-message.ts
import { z as z14 } from "zod";
var stxSignMessageTypeSchema = z14.enum(["utf8", "structured"]);
var stxSignMessageRequestBaseSchema = z14.object({
  messageType: stxSignMessageTypeSchema.optional().default("utf8"),
  network: z14.optional(z14.enum(["mainnet", "testnet", "devnet", "mocknet"]))
});
var stxSignMessageRequestUtf8Schema = stxSignMessageRequestBaseSchema.merge(
  z14.object({
    messageType: z14.literal("utf8").default("utf8"),
    message: z14.string()
  })
);
var stxSignMessageRequestStructuredSchema = stxSignMessageRequestBaseSchema.merge(
  z14.object({
    messageType: z14.literal("structured"),
    domain: z14.string(),
    message: z14.string()
  })
);
var stxSignMessage = defineRpcEndpoint({
  method: "stx_signMessage",
  params: z14.union([stxSignMessageRequestUtf8Schema, stxSignMessageRequestStructuredSchema]),
  result: z14.object({
    signature: z14.string(),
    publicKey: z14.string()
  })
});

// src/methods/stacks/stx-sign-structured-message.ts
import { z as z15 } from "zod";
var stxSignStructuredMessage = defineRpcEndpoint({
  method: "stx_signStructuredMessage",
  params: z15.object({
    domain: z15.string(),
    message: z15.string()
  }),
  result: z15.object({
    signature: z15.string(),
    publicKey: z15.string()
  })
});

// src/methods/stacks/stx-sign-transaction.ts
import { z as z16 } from "zod";
var stxSignTransactionRequestLeatherRpcParamsSchema = z16.object({
  txHex: z16.string(),
  stxAddress: z16.string().optional(),
  attachment: z16.string().optional(),
  accountIndex: z16.string().optional(),
  network: z16.string().optional()
});
var stxSignTransactionRequestSip30ParamsSchema = z16.object({
  transaction: z16.string(),
  network: z16.string().optional()
});
var stxSignTransaction = defineRpcEndpoint({
  method: "stx_signTransaction",
  params: z16.union([
    stxSignTransactionRequestLeatherRpcParamsSchema,
    stxSignTransactionRequestSip30ParamsSchema
  ]),
  result: z16.object({
    transaction: z16.string(),
    txHex: z16.string()
  })
});

// src/methods/stacks/stx-transfer-sip9-nft.ts
import { z as z17 } from "zod";
var stxTransferSip9Nft = defineRpcEndpoint({
  method: "stx_transferSip9Nft",
  params: z17.intersection(
    z17.object({
      recipient: z17.string(),
      asset: z17.string(),
      assetId: z17.string()
    }),
    baseStacksTransactionConfigSchema
  ),
  result: stacksTransactionDetailsSchema
});

// src/methods/stacks/stx-transfer-sip10-ft.ts
import { z as z18 } from "zod";
var stxTransferSip10Ft = defineRpcEndpoint({
  method: "stx_transferSip10Ft",
  params: z18.intersection(
    z18.object({
      recipient: z18.string(),
      asset: z18.string(),
      amount: z18.coerce.number()
    }),
    baseStacksTransactionConfigSchema
  ),
  result: stacksTransactionDetailsSchema
});

// src/methods/stacks/stx-transfer-stx.ts
import { z as z19 } from "zod";
var stxTransferStx = defineRpcEndpoint({
  method: "stx_transferStx",
  params: z19.intersection(
    z19.object({
      recipient: z19.string(),
      amount: z19.coerce.number(),
      memo: z19.string().optional()
    }),
    baseStacksTransactionConfigSchema
  ),
  result: stacksTransactionDetailsSchema
});

// src/methods/stacks/stx-update-profile.ts
import { z as z20 } from "zod";
var stxUpdateProfileRequestParamsSchema = z20.object({
  // schema.org/Person
  person: z20.object({}).passthrough()
});
var stxUpdateProfileResponseBodySchema = stacksTransactionDetailsSchema;
var stxUpdateProfile = defineRpcEndpoint({
  method: "stx_updateProfile",
  params: stxUpdateProfileRequestParamsSchema,
  result: stxUpdateProfileResponseBodySchema
});

// src/methods/supported-methods.ts
import { z as z21 } from "zod";
var supportedMethodSchema = z21.object({
  name: z21.string(),
  docsUrl: z21.union([z21.string(), z21.array(z21.string())])
});
var supportedMethods = defineRpcEndpoint({
  method: "supportedMethods",
  result: z21.object({
    documentation: z21.string(),
    methods: z21.array(supportedMethodSchema)
  })
});

// src/methods/stacks/_clarity-values.ts
import { z as z22 } from "zod";
var cvIntSchema = z22.object({
  type: z22.literal("int"),
  value: z22.coerce.string()
});
var cvUintSchema = z22.object({
  type: z22.literal("uint"),
  value: z22.coerce.string()
});
var cvBufferSchema = z22.object({
  type: z22.literal("buffer"),
  value: z22.string()
});
var cvTrueSchema = z22.object({
  type: z22.literal("true")
});
var cvFalseSchema = z22.object({
  type: z22.literal("false")
});
var cvAddressSchema = z22.object({
  type: z22.literal("address"),
  value: z22.string()
});
var cvContractSchema = z22.object({
  type: z22.literal("contract"),
  value: z22.string().refine((value) => value.includes("."), {
    message: "Stacks contract principals are denoted with a dot"
  })
});
var cvAsciiSchema = z22.object({
  type: z22.literal("ascii"),
  value: z22.string()
});
var cvUtf8Schema = z22.object({
  type: z22.literal("utf8"),
  value: z22.string()
});
var cvOkSchema = z22.object({
  type: z22.literal("ok"),
  value: z22.lazy(() => clarityValueSchema)
}).transform((value) => value);
var cvErrSchema = z22.object({
  type: z22.literal("err"),
  value: z22.lazy(() => clarityValueSchema)
});
var cvNoneSchema = z22.object({
  type: z22.literal("none")
});
var cvSomeSchema = z22.object({
  type: z22.literal("some"),
  value: z22.lazy(() => clarityValueSchema)
});
var cvListSchema = z22.object({
  type: z22.literal("list"),
  value: z22.array(z22.lazy(() => clarityValueSchema))
});
var cvTupleSchema = z22.object({
  type: z22.literal("tuple"),
  value: z22.record(z22.lazy(() => clarityValueSchema))
});
var clarityValueSchema = z22.union([
  cvIntSchema,
  cvUintSchema,
  cvBufferSchema,
  cvTrueSchema,
  cvFalseSchema,
  cvAddressSchema,
  cvContractSchema,
  cvOkSchema,
  cvErrSchema,
  cvNoneSchema,
  cvSomeSchema,
  cvListSchema,
  cvTupleSchema,
  cvAsciiSchema,
  cvUtf8Schema
]);

// src/index.ts
var endpoints = {
  getAddresses,
  getInfo,
  open,
  openSwap,
  sendTransfer,
  signMessage,
  signPsbt,
  stxCallContract,
  stxDeployContract,
  stxGetAddresses,
  stxGetNetworks,
  stxSignMessage,
  stxSignStructuredMessage,
  stxSignTransaction,
  stxTransferSip10Ft,
  stxTransferSip9Nft,
  stxTransferStx,
  stxUpdateProfile,
  supportedMethods
};
function createRpcSuccessResponse(_method, response) {
  return { jsonrpc: "2.0", ...response };
}
function createRpcErrorResponse(_method, error) {
  return { jsonrpc: "2.0", ...error };
}
export {
  Bip322MessageTypesSchema,
  RpcErrorCode,
  addressResponseBodySchema,
  addressSchema,
  baseStacksTransactionConfigSchema,
  bitcoinPaymentTypesSchema,
  btcAddressBaseSchema,
  btcAddressSchema,
  clarityValueSchema,
  createRequestEncoder,
  createRpcErrorBodySchema,
  createRpcErrorResponse,
  createRpcErrorResponseSchema,
  createRpcRequestSchema,
  createRpcResponseSchema,
  createRpcSuccessResponse,
  createRpcSuccessResponseSchema,
  cvAddressSchema,
  cvAsciiSchema,
  cvBufferSchema,
  cvContractSchema,
  cvErrSchema,
  cvFalseSchema,
  cvIntSchema,
  cvListSchema,
  cvNoneSchema,
  cvOkSchema,
  cvSomeSchema,
  cvTrueSchema,
  cvTupleSchema,
  cvUintSchema,
  cvUtf8Schema,
  decodeBase64Json,
  defaultErrorSchema,
  defineRpcEndpoint,
  encodeBase64Json,
  endpoints,
  getAddresses,
  getInfo,
  open,
  openSwap,
  rpcBasePropsSchema,
  rpcParameterSchema,
  sendTransfer,
  signMessage,
  signMessageRequestParamsSchema,
  signPsbt,
  signatureHash,
  stacksTransactionDetailsSchema,
  stxAddressItemSchema,
  stxAddressSchema,
  stxCallContract,
  stxDeployContract,
  stxDeployContractResponseBodySchema,
  stxGetAddresses,
  stxGetAddressesResponseBodySchema,
  stxSignMessage,
  stxSignMessageRequestBaseSchema,
  stxSignMessageRequestStructuredSchema,
  stxSignMessageRequestUtf8Schema,
  stxSignMessageTypeSchema,
  stxSignStructuredMessage,
  stxSignTransaction,
  stxSignTransactionRequestLeatherRpcParamsSchema,
  stxSignTransactionRequestSip30ParamsSchema,
  stxTransferSip10Ft,
  stxTransferSip9Nft,
  stxTransferStx,
  stxUpdateProfile,
  stxUpdateProfileRequestParamsSchema,
  stxUpdateProfileResponseBodySchema,
  supportedMethodSchema,
  supportedMethods,
  testIsNumberOrArrayOfNumbers
};
//# sourceMappingURL=index.js.map