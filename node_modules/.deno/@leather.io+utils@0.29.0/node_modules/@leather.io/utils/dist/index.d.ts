import BigNumber, { BigNumber as BigNumber$1 } from 'bignumber.js';
import { Money, MarketData, NumType, Currency, AccountId, AccountAddresses, BitcoinAddressInfo, StacksAddressInfo, CryptoAssetInfo, BaseCryptoAssetBalance, BtcCryptoAssetBalance, StxCryptoAssetBalance, NetworkModes } from '@leather.io/models';

declare function createCounter(startPosition?: number): {
    getValue(): number;
    increment(): number;
    incrementBy(amount: number): number;
    decrement(): number;
};

declare function calculateMeanAverage(numbers: BigNumber[] | number[]): BigNumber;

declare function fibonacciGenerator(startIndex?: number): IterableIterator<number>;

declare function initBigNumber(num: string | number | BigNumber | bigint): BigNumber;
declare function isEven(num: number): boolean;
declare function countDecimals(num: string | number | BigNumber): number;
declare function increaseValueByOneMicroStx(value: string | number | BigNumber): number;

declare function baseCurrencyAmountInQuoteWithFallback(quantity: Money, marketData?: MarketData): Money;
declare function baseCurrencyAmountInQuote(quantity: Money, { pair, price }: MarketData): Money;
declare function convertAmountToFractionalUnit(num: Money | BigNumber$1, decimals?: number): BigNumber$1;
declare function convertToMoneyTypeWithDefaultOfZero(symbol: string, num?: NumType, decimals?: number): Money;
declare function convertAmountToBaseUnit(num: Money | BigNumber$1, decimals?: number): BigNumber$1;
declare function subtractMoney(xAmount: Money, yAmount: Money): Money;
declare function sumMoney(moneysArr: Money[]): Money;

/**
 * @param value Amount described in currency's primary unit
 * @param symbol Identifying letter code, e.g. EUR
 * @param resolution Optional, required if value not known at build-time
 */
declare function createMoneyFromDecimal(value: NumType, symbol: Currency, resolution?: number): Money;
/**
 * @param value Amount described in currency's fractional base unit, e.g. cents for USD amounts
 * @param symbol Identifying letter code, e.g. EUR
 * @param resolution Optional, required if value not known at build-time
 */
declare function createMoney(value: NumType, symbol: Currency, resolution?: number): Money;
declare function formatMoney({ amount, symbol, decimals }: Money): string;
declare function formatMoneyWithoutSymbol({ amount, decimals }: Money): string;
declare function formatMoneyToFixedDecimal({ amount, symbol, decimals }: Money, fixedDecimals: number): string;
declare function formatMoneyToFixedDecimalWithoutSymbol({ amount, decimals }: Money, fixedDecimals: number): string;
declare function formatMoneyPadded({ amount, symbol, decimals }: Money): string;
declare function i18nFormatCurrency(quantity: Money, decimals?: number): string;
declare function formatDustUsdAmounts(value: string): string;

declare function isMoney(val: unknown): val is Money;
declare function isMoneyGreaterThanZero(money: Money): boolean | undefined;

declare function isValidPrecision(amount: number, precision: number): boolean;

declare function unitToFractionalUnit(decimals: number): (unit: number | string | BigNumber) => BigNumber;
declare const satToBtc: (unit: number | string | BigNumber) => BigNumber;
declare const btcToSat: (unit: number | string | BigNumber) => BigNumber;
declare const microStxToStx: (unit: number | string | BigNumber) => BigNumber;
declare const stxToMicroStx: (unit: number | string | BigNumber) => BigNumber;
declare function moneyToBaseUnit(sum: Money): BigNumber;

declare function createAccountAddresses(accountId: AccountId, btcDescriptors?: string[], stxAddress?: string): AccountAddresses;
declare function hasBitcoinAddress(account: AccountAddresses): account is AccountAddresses & {
    bitcoin: BitcoinAddressInfo;
};
declare function hasStacksAddress(account: AccountAddresses): account is AccountAddresses & {
    stacks: StacksAddressInfo;
};

declare function sortAssetsByName<T extends {
    name: string;
}[]>(assets: T): T;
declare function migratePositiveAssetBalancesToTop<T extends {
    balance: Money;
}[]>(assets: T): T;

declare function getAssetDisplayName(asset: CryptoAssetInfo): string;

declare function createBaseCryptoAssetBalance(totalBalance: Money, inboundBal?: Money, outboundBal?: Money): BaseCryptoAssetBalance;
declare function createBtcCryptoAssetBalance(totalBalance: Money, inboundBal?: Money, outboundBal?: Money, protectedBal?: Money, uneconomicalBal?: Money, unspendableBal?: Money): BtcCryptoAssetBalance;
declare function createStxCryptoAssetBalance(totalBalance: Money, inboundBal?: Money, outboundBal?: Money, lockedBal?: Money): StxCryptoAssetBalance;
declare function aggregateBaseCryptoAssetBalances(balances: BaseCryptoAssetBalance[]): BaseCryptoAssetBalance;
declare function aggregateBtcCryptoAssetBalances(balances: BtcCryptoAssetBalance[]): BtcCryptoAssetBalance;
declare function aggregateStxCryptoAssetBalances(balances: StxCryptoAssetBalance[]): StxCryptoAssetBalance;

declare function truncateMiddle(input: string, offset?: number): string;

declare const oneMinInMs: number;
declare const fiveMinInMs: number;
declare const oneDayInMs: number;
declare const oneWeekInMs: number;

interface SpamFilterArgs {
    input: string;
    whitelist: string[];
}
declare function spamFilter({ input, whitelist }: SpamFilterArgs): string;

declare function extractPhraseFromString(value: string): string;

declare function pxStringToNumber(pxString: string): number;

/**
 * TODO: investigate improving
 * @param amount is a string
 * in the extension we pre-convert it from Money with formatMoneyWithoutSymbol
 */
declare function formatBalance(amount: string): {
    isAbbreviated: boolean;
    value: string;
};

declare function abbreviateNumber(n: number): string;

declare function isNumber(value: unknown): value is number;
declare function isString(value: unknown): value is string;
declare function isEmptyString(value: unknown): value is '';
declare function isBigInt(value: unknown): value is bigint;
declare function isUndefined(value: unknown): value is undefined;
declare function isFunction(value: unknown): value is () => void;
declare function isBoolean(value: unknown): value is boolean;
declare function isObject(value: unknown): value is object;
declare function isError(value: unknown): value is Error;
declare function isEmpty(value: object): boolean;
declare function isDefined<T>(argument: T | undefined): argument is T;
declare function isTypedArray(val: unknown): val is Uint8Array;
declare function noop(): void;
declare function ensureArray<T>(value: T | T[]): T[];
declare function undefinedIfLengthZero<T extends any[]>(arr: T): T | undefined;
type NetworkMap<T> = Record<NetworkModes, T>;
declare function whenNetwork(mode: NetworkModes): <T extends NetworkMap<unknown>>(networkMap: T) => T[NetworkModes];
declare function isEmptyArray(data: unknown[]): boolean;
declare const defaultWalletKeyId = "default";
declare function reverseBytes(bytes: Buffer): Buffer;
declare function reverseBytes(bytes: Uint8Array): Uint8Array;
declare function makeNumberRange(num: number): number[];
declare function createNumArrayOfRange(fromIndex: number, toIndex: number): number[];
declare function delay(ms: number): Promise<unknown>;
declare function sumNumbers(nums: number[]): BigNumber$1;
declare function isFulfilled<T>(p: PromiseSettledResult<T>): p is PromiseFulfilledResult<T>;
declare function isRejected<T>(p: PromiseSettledResult<T>): p is PromiseRejectedResult;
declare function createNullArrayOfLength(length: number): any[];
declare function safelyFormatHexTxid(id: string): string;
declare function getTicker(value: string): string;
declare function propIfDefined(prop: string, value: any): {
    [x: string]: boolean;
};
declare function isHexString(value: string): boolean;
declare function toHexString(value: number): string;
declare function hexToNumber(hex: string): number;
type MapFunction<T, U> = (value: T[keyof T], key: string) => U;
declare function mapObject<T extends object, U>(obj: T, mapFn: MapFunction<T, U>): {
    [K in keyof T]: U;
};
declare function assertIsTruthy<T>(val: T): asserts val is NonNullable<T>;
/**
 * Ensure all cases in a control flow are handled by asserting a value is `never`.
 *
 * Typically used in `switch` statements to enforce exhaustiveness.
 * TypeScript's type checking will catch unhandled cases at compile time.
 */
declare function assertUnreachable(value: never): never;
declare function capitalize(val: string): string;
declare function uniqueArray<T>(arr: T[]): T[];
declare function match<Variant extends string | number>(): <T>(variant: Variant, match: Record<Variant, T>) => Record<Variant, T>[Variant];
declare function removeTrailingNullCharacters(s: string): string;
declare function isNumberOrNumberList(value: unknown): value is number | number[];

export { abbreviateNumber, aggregateBaseCryptoAssetBalances, aggregateBtcCryptoAssetBalances, aggregateStxCryptoAssetBalances, assertIsTruthy, assertUnreachable, baseCurrencyAmountInQuote, baseCurrencyAmountInQuoteWithFallback, btcToSat, calculateMeanAverage, capitalize, convertAmountToBaseUnit, convertAmountToFractionalUnit, convertToMoneyTypeWithDefaultOfZero, countDecimals, createAccountAddresses, createBaseCryptoAssetBalance, createBtcCryptoAssetBalance, createCounter, createMoney, createMoneyFromDecimal, createNullArrayOfLength, createNumArrayOfRange, createStxCryptoAssetBalance, defaultWalletKeyId, delay, ensureArray, extractPhraseFromString, fibonacciGenerator, fiveMinInMs, formatBalance, formatDustUsdAmounts, formatMoney, formatMoneyPadded, formatMoneyToFixedDecimal, formatMoneyToFixedDecimalWithoutSymbol, formatMoneyWithoutSymbol, getAssetDisplayName, getTicker, hasBitcoinAddress, hasStacksAddress, hexToNumber, i18nFormatCurrency, increaseValueByOneMicroStx, initBigNumber, isBigInt, isBoolean, isDefined, isEmpty, isEmptyArray, isEmptyString, isError, isEven, isFulfilled, isFunction, isHexString, isMoney, isMoneyGreaterThanZero, isNumber, isNumberOrNumberList, isObject, isRejected, isString, isTypedArray, isUndefined, isValidPrecision, makeNumberRange, mapObject, match, microStxToStx, migratePositiveAssetBalancesToTop, moneyToBaseUnit, noop, oneDayInMs, oneMinInMs, oneWeekInMs, propIfDefined, pxStringToNumber, removeTrailingNullCharacters, reverseBytes, safelyFormatHexTxid, satToBtc, sortAssetsByName, spamFilter, stxToMicroStx, subtractMoney, sumMoney, sumNumbers, toHexString, truncateMiddle, undefinedIfLengthZero, uniqueArray, unitToFractionalUnit, whenNetwork };
